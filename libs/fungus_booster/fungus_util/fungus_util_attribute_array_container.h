#ifndef ATTRIBUTE_ARRAY_CONTAINER_H
#define ATTRIBUTE_ARRAY_CONTAINER_H

#include "fungus_util_common.h"

#include <vector>
#include <climits>

namespace fungus_util
{
    // some typedefs
    typedef int32_t attribute_array_id;
    typedef uint32_t attribute_index_type;

    // special values
    static constexpr attribute_array_id none_attribute_array_id = INT_MIN;

    static constexpr attribute_index_type attribute_index_none = (attribute_index_type)-1;

    static constexpr size_t attribute_array_default_index = (size_t)-1;

    // attribute dependency relationship
    enum dependency_relationship_e
    {
        parent_dependency,
        self_dependency,
        default_dependency
    };

    enum post_exchange_action_e
    {
        post_exchange_action_recompute_all,
        post_exchange_action_recompute_left,
        post_exchange_action_recompute_right,
        post_exchange_action_none
    };

    enum attribute_array_exchange_method_e
    {
        attribute_array_exchange_swap,
        attribute_array_exchange_copy_right,
        attribute_array_exchange_copy_left
    };


    // a pair of indices generated by a relational iterator
    struct dependency_index_pair
    {
        size_t i_parent;
        size_t i_self;
    };

    namespace detail
    {
        // first definition for dependency_index_extractor, always returns parent index
        template <dependency_relationship_e _relationship>
        struct dependency_index_selector
        {
            static size_t select(const dependency_index_pair &m_pair)
            {
                return m_pair.i_parent;
            }
        };

        // partial specialization for self_dependency.
        template <>
        struct dependency_index_selector<self_dependency>
        {
            static size_t select(const dependency_index_pair &m_pair)
            {
                return m_pair.i_self;
            }
        };

        // partial specialization for default_dependency.
        template <>
        struct dependency_index_selector<default_dependency>
        {
            static size_t select(const dependency_index_pair &m_pair)
            {
                // just return the default index, disregarding the pair
                return attribute_array_default_index;
            }
        };

        // given a source pack of attribute_array_def types and a dependency,
        // it will extract as much information as possible about the dependency
        // through variadic recursive unrolling.
        template <typename attribute_array_dependency_defT, typename... attribute_array_defT>
        struct resolved_dependency_def;

        template <typename attribute_array_dependency_defT, typename attribute_array_defT, typename... attribute_array_defU>
        struct resolved_dependency_def<attribute_array_dependency_defT, attribute_array_defT, attribute_array_defU...>
        {
            typedef
                attribute_array_defT
                __current_attribute_array_def_type;

            // the conditional type instantiation metaprogramming tool is
            // used here to recursively select the attribute_array_def type
            // associated with the dependency's ID.
            typedef
                typename std::conditional<attribute_array_defT::ID == attribute_array_dependency_defT::ID,
                                 __current_attribute_array_def_type,
                                 typename resolved_dependency_def<attribute_array_dependency_defT, attribute_array_defU...>::attribute_array_def_type>::type
                attribute_array_def_type;

            // define all constant information here too, so that it can also act as a plain dependency.
            typedef
                typename attribute_array_def_type::type
                type;

            static constexpr attribute_array_id        ID                      = attribute_array_dependency_defT::ID;
            static constexpr dependency_relationship_e dependency_relationship = attribute_array_dependency_defT::dependency_relationship;

            // convenience definition that attaches a dependency index selector
            typedef
                dependency_index_selector<dependency_relationship>
                dependency_index_selector_type;
        };

        // the empty case.  should cause a bunch of compile time assertions if it
        // is ever reached, which would mean that your setup is invalid because of:
        // an incorrect ID, an empty attribute array container, etc.
        template <typename attribute_array_dependency_defT>
        struct resolved_dependency_def<attribute_array_dependency_defT>
        {
            struct __attribute_array_def
            {
                typedef void type;
                static constexpr attribute_array_id ID = none_attribute_array_id;

                struct recompute_functor_type
                {
                    typedef type return_type;

                    inline return_type operator()() {return return_type();}
                };
            };

            typedef
                __attribute_array_def
                attribute_array_def_type;

            typedef
                int
                type;

            static constexpr attribute_array_id        ID                      = none_attribute_array_id;
            static constexpr dependency_relationship_e dependency_relationship = parent_dependency;

            typedef
                dependency_index_selector<dependency_relationship>
                dependency_index_selector_type;
        };

        // each attribute_array_def type instantiates one of these
        // by passing it's dependency argument pack through here.
        template <typename... attribute_array_dependency_defT>
        struct dependency_def_list_unroller
        {
            // the contained type requires the passing of the full
            // attribute array definition pack, so this is instantiated
            // for each attribute array from the attribute array container,
            // which takes the full list as an argument pack.
            template <typename... attribute_array_defT>
            struct __impl_s
            {
                template <typename target_attribute_array_defT, typename attribute_array_containerT>
                static inline bool needs_recompute(target_attribute_array_defT __dummy, const dependency_index_pair &m_pair,
                                                   attribute_array_containerT &m_container)
                {
                    // pass each change flag to a recursive variadic or function.
                    return recursive_or
                    (
                        (m_container.get_attribute_array // get the attribute array resolved from the dependency information
                        (
                            typename resolved_dependency_def
                            <
                                attribute_array_dependency_defT,
                                attribute_array_defT...
                            >::attribute_array_def_type()
                        ).get
                        (
                            // select the correct index from the parent/self pair
                            // from the dependency information
                            resolved_dependency_def
                            <
                                attribute_array_dependency_defT,
                                attribute_array_defT...
                            >::dependency_index_selector_type::select
                            (
                                m_pair
                            )
                        ).first)...
                    );
                }

                // the function itself operates on a specific attribute array and dependency
                // index pair, and this is called for each case in order during runtime because
                // the concrete index dependency relationships are mutable.
                // we pass a variadic list of dependencies to the recompute functor by getting the
                // attribute array for the dependency, then selecting the correct index from the pair
                // passing that to the [] operator to get the value.
                template <typename target_attribute_array_defT, typename attribute_array_containerT>
                static auto recompute(target_attribute_array_defT __dummy,
                                      const dependency_index_pair &m_pair,
                                      attribute_array_containerT &m_container,
                                      typename target_attribute_array_defT::recompute_functor_type m_functor)
                    -> typename target_attribute_array_defT::recompute_functor_type::return_type
                                                          // return a runtime conditional of the same type as
                                                          // the recompute functor which has to at least be
                                                          // cast-able to the target attribute type in your setup.
                {
                    return m_functor
                    (
                        (m_container.get_attribute_array // get the attribute array resolved from the dependency information
                        (
                            typename resolved_dependency_def
                            <
                                attribute_array_dependency_defT,
                                attribute_array_defT...
                            >::attribute_array_def_type()
                        ).get
                        (
                            // select the correct index from the parent/self pair
                            // from the dependency information
                            resolved_dependency_def
                            <
                                attribute_array_dependency_defT,
                                attribute_array_defT...
                            >::dependency_index_selector_type::select
                            (
                                m_pair
                            )
                        ).second)... // perform this for each in argument pack attribute_array_dependency_defT
                                    // and pass the variadic argument pack produced as an argument list to the recompute functor
                    );
                }
            };
        };

        // each attribute_array_def type instantiates one of these
        // by passing it's dependency argument pack through here.
        template <>
        struct dependency_def_list_unroller<>
        {
            // the contained type requires the passing of the full
            // attribute array definition pack, so this is instantiated
            // for each attribute array from the attribute array container,
            // which takes the full list as an argument pack.
            template <typename... attribute_array_defT>
            struct __impl_s
            {
                template <typename target_attribute_array_defT, typename attribute_array_containerT>
                static inline bool needs_recompute(target_attribute_array_defT __dummy, const dependency_index_pair &m_pair,
                                                   attribute_array_containerT &m_container)
                {
                    return false;
                }

                // the function itself operates on a specific attribute array and dependency
                // index pair, and this is called for each case in order during runtime because
                // the concrete index dependency relationships are mutable.
                // we pass a variadic list of dependencies to the recompute functor by getting the
                // attribute array for the dependency, then selecting the correct index from the pair
                // passing that to the [] operator to get the value.
                template <typename target_attribute_array_defT, typename attribute_array_containerT>
                static auto recompute(target_attribute_array_defT __dummy,
                                      const dependency_index_pair &m_pair,
                                      attribute_array_containerT &m_container,
                                      typename target_attribute_array_defT::recompute_functor_type m_functor)
                    -> typename target_attribute_array_defT::recompute_functor_type::return_type
                                                          // return a runtime conditional of the same type as
                                                          // the recompute functor which has to at least be
                                                          // cast-able to the target attribute type in your setup.
                {
                    return typename target_attribute_array_defT::recompute_functor_type::return_type();
                }
            };
        };

        template <post_exchange_action_e _exchange_action>
        struct __attribute_array_exchanger_post_action_helper
        {
            template <typename attribute_arrayT, typename attribute_arrayU>
            static inline void __impl(attribute_arrayT &m_a, attribute_arrayU &m_b) {}
        };

        template <>
        struct __attribute_array_exchanger_post_action_helper<post_exchange_action_recompute_all>
        {
            template <typename attribute_arrayT, typename attribute_arrayU>
            static inline void __impl(attribute_arrayT &m_a, attribute_arrayU &m_b)
            {
                m_a.set_recompute_flags();
                m_b.set_recompute_flags();
            }
        };

        template <>
        struct __attribute_array_exchanger_post_action_helper<post_exchange_action_recompute_left>
        {
            template <typename attribute_arrayT, typename attribute_arrayU>
            static inline void __impl(attribute_arrayT &m_a, attribute_arrayU &m_b)
            {
                m_a.set_recompute_flags();
            }
        };

        template <>
        struct __attribute_array_exchanger_post_action_helper<post_exchange_action_recompute_right>
        {
            template <typename attribute_arrayT, typename attribute_arrayU>
            static inline void __impl(attribute_arrayT &m_a, attribute_arrayU &m_b)
            {
                m_b.set_recompute_flags();
            }
        };

        template <typename attribute_arrayT, typename attribute_arrayU>
        struct __move_same_swap_impl
        {
            typedef
                typename attribute_arrayT::element_type
                element_type;

            static inline void __swap_op(attribute_arrayT &m_a, attribute_arrayU &m_b)
            {
                m_a.m_elems.swap(m_b.m_elems);

                element_type m_tmp_element(std::move(m_a.m_default_value));
                m_a.m_default_value = std::move(m_b.m_default_value);
                m_b.m_default_value = std::move(m_tmp_element);
            }

            static inline void __copy_from_op(attribute_arrayT &m_a, const attribute_arrayU &m_b)
            {
                m_a.m_elems = m_b.m_elems;
                m_a.m_default_value = m_b.m_default_value;
            }
        };

        template <typename attribute_arrayT, typename attribute_arrayU>
        struct __castable_type_swap_impl
        {
            typedef
                typename attribute_arrayT::type
                left_type;

            typedef
                typename attribute_arrayU::type
                right_type;

            typedef
                typename attribute_arrayT::element_type
                left_element_type;

            typedef
                typename attribute_arrayU::element_type
                right_element_type;

            static inline left_element_type __right_to_left(const right_element_type &m)
            {
                return left_element_type(m.first, left_type(m.second));
            }

            static inline right_element_type __left_to_right(const left_element_type &m)
            {
                return right_element_type(m.first, right_type(m.second));
            }

            static inline void __swap_op(attribute_arrayT &m_a, attribute_arrayU &m_b)
            {
                std::vector<left_element_type>  __lt_vec;
                std::vector<right_element_type> __rt_vec;

                __lt_vec.reserve(m_b.m_elems.size());
                __rt_vec.reserve(m_a.m_elems.size());

                for (const left_element_type &entry: m_a.m_elems)
                    __rt_vec.push_back(__left_to_right(entry));

                for (const right_element_type &entry: m_b.m_elems)
                    __lt_vec.push_back(__right_to_left(entry));

                m_a.m_elems.swap(__lt_vec);
                m_b.m_elems.swap(__rt_vec);

                right_element_type __tmp = __left_to_right(m_a.m_default_value);
                m_a.m_default_value = __right_to_left(m_b.m_default_value);
                m_b.m_default_value = std::move(__tmp);
            }

            static inline void __copy_from_op(attribute_arrayT &m_a, const attribute_arrayU &m_b)
            {
                m_a.m_elems.clear();
                m_a.m_elems.reserve(m_b.m_elems.size());

                for (const right_element_type &entry: m_b.m_elems)
                    m_a.m_elems.push_back(__right_to_left(entry));

                m_a.m_default_value = __right_to_left(m_b.m_default_value);
            }
        };

        template <attribute_array_exchange_method_e _exchange_method = attribute_array_exchange_swap>
        struct __attribute_array_exchanger_op
        {
            template <typename attribute_arrayT, typename attribute_arrayU>
            static inline void __impl(attribute_arrayT &__lt, attribute_arrayU &__rt)
            {
                __lt.swap(__rt);
            }
        };

        template <>
        struct __attribute_array_exchanger_op<attribute_array_exchange_copy_right>
        {
            template <typename attribute_arrayT, typename attribute_arrayU>
            static inline void __impl(attribute_arrayT &__lt, attribute_arrayU &__rt)
            {
                __rt.copy_from(__lt);
            }
        };

        template <>
        struct __attribute_array_exchanger_op<attribute_array_exchange_copy_left>
        {
            template <typename attribute_arrayT, typename attribute_arrayU>
            static inline void __impl(attribute_arrayT &__lt, attribute_arrayT &__rt)
            {
                __lt.copy_from(__rt);
            }
        };

        template <size_t _n>
        struct __select_size_source
        {
            static inline size_t __impl(size_t _o)
            {
                return _n;
            }
        };

        template <>
        struct __select_size_source<0>
        {
            static inline size_t __impl(size_t _o)
            {
                return _o > 0 ? _o : 1;
            }
        };
    };

    // exchange two attributes.
    // if the attributes are defined with the same
    // type then the __move_same_swap_impl attribute
    // array swap is instantiated by the call to
    // swap(), which will just temp swap the vectors
    // with move semantics, which is equivalent
    // to copy temp swapping the underlying array
    // pointers; O(1). if they are of differing types
    // then __castable_type_swap_impl is instantiated.
    // this tries to use constructor cast semantics
    // to cast them both ways during the exchange;
    // O(n).  If no cast exists between said types,
    // compile time errors about "no known conversion"
    // or some such will be generated.
    template <typename attribute_array_defT, typename attribute_array_defU,
              attribute_array_exchange_method_e _exchange_method = attribute_array_exchange_swap,
              post_exchange_action_e            _exchange_action = post_exchange_action_none>
    struct non_uniform_attribute_array_exchanger
    {
        static constexpr post_exchange_action_e            exchange_action = _exchange_action;
        static constexpr attribute_array_exchange_method_e exchange_method = _exchange_method;

        template <typename attribute_array_containerT, typename attribute_array_containerU>
        inline void operator()(attribute_array_containerT &m_a, attribute_array_containerU &m_b)
        {
            auto &__lt = m_a.get_attribute_array(attribute_array_defT());
            auto &__rt = m_b.get_attribute_array(attribute_array_defU());

            detail::__attribute_array_exchanger_op<exchange_method>::__impl(__lt, __rt);
            detail::__attribute_array_exchanger_post_action_helper<exchange_action>::__impl(__lt, __rt);
        }
    };

    template <typename attribute_array_defT,
              attribute_array_exchange_method_e _exchange_method = attribute_array_exchange_swap,
              post_exchange_action_e            _exchange_action = post_exchange_action_none>
    struct attribute_array_exchanger:
        non_uniform_attribute_array_exchanger<attribute_array_defT, attribute_array_defT, _exchange_method, _exchange_action>
    {};

    template <typename attribute_array_defT>
    struct simple_attribute_array_exchanger:
        attribute_array_exchanger<attribute_array_defT, attribute_array_exchange_swap, post_exchange_action_none>
    {};

    // this doodad is a code batch of exchangers, useful for those times when you
    // need to compress some instructions further down in your recomputation machine
    // when excessive swapping is done.
    template <typename... attribute_array_exchangerT>
    struct attribute_array_exchanger_batch;

    // recursive case
    template <typename attribute_array_exchangerT, typename... attribute_array_exchangerU>
    struct attribute_array_exchanger_batch<attribute_array_exchangerT, attribute_array_exchangerU...>
    {
        template <typename attribute_array_containerT, typename attribute_array_containerU>
        inline void operator()(attribute_array_containerT &m_a, attribute_array_containerU &m_b)
        {
            static attribute_array_exchangerT                                     __exchanger;
            static attribute_array_exchanger_batch<attribute_array_exchangerU...> __next;

            __exchanger(m_a, m_b);
            __next(m_a, m_b);
        }
    };

    // tail case.
    template <>
    struct attribute_array_exchanger_batch<>
    {
        template <typename attribute_array_containerT, typename attribute_array_containerU>
        inline void operator()(attribute_array_containerT &m_a, attribute_array_containerU &m_b) {}
    };

    // definition of an attribute array dependency.
    // has a relationship (self/parent) and an ID for the dependency in question.
    template <attribute_array_id _ID, dependency_relationship_e _relationship>
    struct attribute_array_dependency_def
    {
        static constexpr attribute_array_id ID                             = _ID;
        static constexpr dependency_relationship_e dependency_relationship = _relationship;
    };

    // a sized attribute array definition.
    // this is the master instantiation template that decides the resize policy
    // for the array produced.  if the size parameter is 0, then the array
    // is dynamically sized and will be resized by default when a resize() call
    // is made on the attribute array container instantiated with this definition.
    // otherwise, the size of that attribute array will remain fixed on a resize()
    // call, so the only way to modify it's size is through an explicit call to
    // do so on the attribute array itself.
    template <size_t _size, typename T, attribute_array_id _ID, typename recomputeT, typename... attribute_array_dependency_defT>
    struct sized_attribute_array_def
    {
        typedef T type;
        static constexpr attribute_array_id ID = _ID;

        static constexpr size_t initial_size = _size; // force the initial size of the attribute array if non-zero

        typedef
            detail::dependency_def_list_unroller<attribute_array_dependency_defT...>
            dependency_def_list_unroller_type;

        typedef
            recomputeT
            recompute_functor_type;
    };

    // variant that has no dependencies
    template <size_t _size, typename T, attribute_array_id _ID>
    struct sized_attribute_array_no_deps_def
    {
        typedef T type;
        static constexpr attribute_array_id ID = _ID;

        static constexpr size_t initial_size = _size;

        typedef
            detail::dependency_def_list_unroller<>
            dependency_def_list_unroller_type;

        struct recompute_functor_type
        {
            typedef type return_type;

            inline return_type operator()() {return return_type();}
        };
    };

    // the singleton variant is here for a more readable idiom than <1, T, _ID, etc...>
    // so that singleton attributes can be used for optimization purposes.  they work a lot
    // like GLSL uniforms.  basically anything that depends on a singleton can use the default_dependency
    // dependency policy, and that will always just access the default out of bounds value for the array.
    // manually changing that value will trigger a recomputation of everything that depends on it, which
    // will always be every index for said dependent attribute.
    template <typename T, attribute_array_id _ID, typename recomputeT, typename... attribute_array_dependency_defT>
    struct singleton_attribute_array_def:
        sized_attribute_array_def<1, T, _ID, recomputeT, attribute_array_dependency_defT...>
    {};

    // no dependencies variant.
    template <typename T, attribute_array_id _ID>
    struct singleton_attribute_array_no_deps_def:
        sized_attribute_array_no_deps_def<1, T, _ID>
    {};

    // variant that has no preferred size by default.  this would be used for
    // most attributes.
    template <typename T, attribute_array_id _ID, typename recomputeT, typename... attribute_array_dependency_defT>
    struct attribute_array_def:
        sized_attribute_array_def<0, T, _ID, recomputeT, attribute_array_dependency_defT...>
    {};

    // no dependencies variant.
    template <typename T, attribute_array_id _ID>
    struct attribute_array_no_deps_def:
        sized_attribute_array_no_deps_def<0, T, _ID>
    {};

    // attribute array class.
    // attribute_array_defT contains
    // a typedef of the element type, an attribute ID,
    // and an attribute configuration
    template <typename attribute_array_defT>
    class attribute_array
    {
    public:
        template <typename, typename>
        friend class detail::__move_same_swap_impl;

        template <typename, typename>
        friend class detail::__castable_type_swap_impl;

        // attribute definition that instantiated this attribute_array
        typedef
            attribute_array_defT
            attribute_array_def_type;

        // the attribute value class
        typedef
            typename attribute_array_def_type::type
            type;

        // the element type stored in the vector.  a pair with type and bool,
        // where the type holds the value and the bool is a flag indicating the
        // need to recompute it's children.
        typedef
            std::pair<bool, type>
            element_type;

        // the attribute ID
        static constexpr attribute_array_id ID = attribute_array_def_type::ID;
    private:
        // default value that's modified and returned by any access on an out
        // of bounds index.  this value should be an identity of sorts, because
        // it will be passed to any other attribute cells that depend on it.
        element_type m_default_value;

        // the vector holding the contents.
        std::vector<element_type> m_elems;

        // gets a reference to the element mapped to i.
        // an out of bounds index will return the
        // default element.
        inline element_type &get_element(size_t i)
        {
            if (i >= m_elems.size())
                return m_default_value;
            else
                return m_elems[i];
        }

        // gets a reference to the element mapped to i.
        // an out of bounds index will return the
        // default element.
        inline constexpr const element_type &get_element(size_t i) const
        {
            if (i >= m_elems.size())
                return m_default_value;
            else
                return m_elems[i];
        }
    public:
        // constexpr attribute_array constructor.
        // allows you to initialize an image of the array
        // during compile time so that it's ready to go
        // right after load time.
        constexpr attribute_array(size_t n = 1):
            m_default_value(true, type()),
            m_elems(detail::__select_size_source<attribute_array_defT::initial_size>::__impl(n), element_type(true, type()))
        {}

        // get the rtti info and attribute ID associated
        // with this attribute_array.  these are constexpr'd
        // as well, so this is 100% compile-time unless the
        // presence of a non concrete class infects it with
        // type ambiguity.
        constexpr type_info_wrap get_type() const   {return typeid(type);}
        constexpr attribute_array_id get_id() const {return ID;}

        // set the value element mapped to i.
        // sets the recompute flag.
        // move assignment variant.
        inline void set(size_t i, type &&v)
        {
            get_element(i).first = true;
            get_element(i).second = std::move(v);
        }

        // set the value element mapped to i.
        // sets the recompute flag.
        // copy assignment variant.
        inline void set(size_t i, const type &v)
        {
            get_element(i).first = true;
            get_element(i).second = v;
        }

        // returns a reference to the element mapped to i.
        inline element_type &get(size_t i)
        {
            return get_element(i);
        }

        // returns a reference to the element mapped to i.
        inline const element_type &get(size_t i) const
        {
            return get_element(i);
        }

        // array accessor.
        inline       type &operator[](size_t i)       {return get_element(i).second;}
        inline const type &operator[](size_t i) const {return get_element(i).second;}

        // resize the vector.
        void resize(size_t n)
        {
            int n_chg = (int)n - (int)size();

            if (n_chg > 0)
            {
                m_elems.reserve(next_pow2(n));
                while (n_chg-- > 0)
                    m_elems.push_back(element_type(true, type()));
            }
            else
                m_elems.resize(n);
        }

        // gets the size of the vector.
        // constexpr'd so you can get the initial size assigned during compile time.
        constexpr size_t size() const
        {
            return m_elems.size();
        }

        // swap this attribute array with another defined with a compatible type.
        template <typename attribute_arrayU>
        void swap(attribute_arrayU &m_o)
        {
            // conditionally instantiate and call the correct
            // static functor for the job.  if both attribute arrays
            // have the exact same element type then we do a pure
            // move semantics swap, which means no allocation/deallocation.
            //
            // if they are not the same type, then we fall back the copy swap,
            // which tries to explicitly cast and copy the types, which (if
            // they are castable to one another) is slower because it requires
            // O(n) copies and the allocation of two temporary vectors.
            //
            // the move swap is always O(1) because we are performing a fixed
            // pointer swap between the vectors through m_a.m_elems.swap(m_b.m_elems).
            //
            // if the types are not castable to one another, calling this function
            // with produce a compile time error "no matching function call" or some
            // such, meaning that the implementation did an invalid copy constructor
            // cast (because there is none for the types).
            std::conditional
            <
                std::is_same<element_type, typename attribute_arrayU::element_type>::value,
                detail::__move_same_swap_impl<attribute_array, attribute_arrayU>,
                detail::__castable_type_swap_impl<attribute_array, attribute_arrayU>
            >::type::__swap_op(*this, m_o);
        }

        template <typename attribute_arrayU>
        void copy_from(const attribute_arrayU &m_o)
        {
            std::conditional
            <
                std::is_same<element_type, typename attribute_arrayU::element_type>::value,
                detail::__move_same_swap_impl<attribute_array, attribute_arrayU>,
                detail::__castable_type_swap_impl<attribute_array, attribute_arrayU>
            >::type::__copy_from_op(*this, m_o);
        }

        // reset all recompute flags to false
        void reset_recompute_flags()
        {
            m_default_value.first = false;
            for (auto &entry: m_elems)
                entry.first = false;
        }

        void set_recompute_flags()
        {
            m_default_value.first = true;
            for (auto &entry: m_elems)
                entry.first = true;
        }
    };

    // recompute flag action instantiators
    // that can be passed to the recompute
    // functions on attribute_array_container
    // in order to decide in compile time
    // whether or not that call to recompute
    // should also reset all of the recompute
    // flags.
    struct post_recompute_flag_action_reset {};
    struct post_recompute_flag_action_none {};

    // a consolidation of variadic argument pack
    // dependent operations on an attribute_array_container.
    namespace detail
    {
        template <typename... attribute_array_defT>
        struct attribute_array_container_ops;

        // partial specialization that extracts the next argument from the list
        template <typename attribute_array_defT, typename... attribute_array_defU>
        struct attribute_array_container_ops<attribute_array_defT, attribute_array_defU...>
        {
            typedef
                attribute_array_container_ops<attribute_array_defU...>
                next_type;

            // the build function called by the constructor
            static inline void build(size_t n_elems, std::vector<any_type> &m_arrays)
            {
                attribute_array<attribute_array_defT> *m_array = new attribute_array<attribute_array_defT>(n_elems);

                m_arrays.push_back(m_array);
                attribute_array_container_ops<attribute_array_defU...>::build(n_elems, m_arrays); // recursive instantiation
            }

            // resize all arrays to the same size unless they are fixed.
            static inline void resize_all(size_t n_elems, std::vector<any_type> &m_arrays, size_t i = 0)
            {
                attribute_array<attribute_array_defT> *m_array = any_cast<attribute_array<attribute_array_defT> *>(m_arrays[i]);

                if (attribute_array_defT::initial_size == 0)
                    m_array->resize(n_elems);

                attribute_array_container_ops<attribute_array_defU...>::resize_all(n_elems, m_arrays, ++i); // recursive instantiation
            }

            // resize all uniformly sized arrays only to the same size.
            // in other words, any arrays which have been manually resized
            // to a size other than the container size will be left as-is.
            static inline void resize_uniform_only(size_t n_elems_old, size_t n_elems_new, std::vector<any_type> &m_arrays, size_t i = 0)
            {
                attribute_array<attribute_array_defT> *m_array = any_cast<attribute_array<attribute_array_defT> *>(m_arrays[i]);

                if (m_array->size() == n_elems_old && attribute_array_defT::initial_size == 0)
                    m_array->resize(n_elems_new);

                attribute_array_container_ops<attribute_array_defU...>::resize_uniform_only(n_elems_old, n_elems_new, m_arrays, ++i); // recursive instantiation
            }

            // reset all recompute flags
            static inline void reset_all_recompute_flags(std::vector<any_type> &m_arrays, size_t i = 0)
            {
                attribute_array<attribute_array_defT> *m_array = any_cast<attribute_array<attribute_array_defT> *>(m_arrays[i]);
                m_array->reset_recompute_flags();

                attribute_array_container_ops<attribute_array_defU...>::reset_all_recompute_flags(m_arrays, ++i); // recursive instantiation
            }

            // the build function called by the destructor
            static inline void destroy(std::vector<any_type> &m_arrays, size_t i = 0)
            {
                delete any_cast<attribute_array<attribute_array_defT> *>(m_arrays[i]);
                attribute_array_container_ops<attribute_array_defU...>::destroy(m_arrays, ++i); // recursive instantiation
            }

            // gets the index of an attribute array recursively at compile time.
            template <typename target_attribute_array_defT>
            static constexpr size_t get_attribute_index(size_t i = 0)
            {
                // check to see if the current attribute array definition is the same type as the
                // target and returns the current index if it is.
                return std::is_same<target_attribute_array_defT, attribute_array_defT>::value == true ?
                       i : attribute_array_container_ops<attribute_array_defU...>::template get_attribute_index<target_attribute_array_defT>(i + 1); // recursive instantiation
            }

            // gets the index of an attribute array recursively at compile time.
            template <typename target_attribute_array_defT>
            static constexpr bool has_attribute_array()
            {
                return get_attribute_index<target_attribute_array_defT>() != attribute_index_none;
            }

            // convenience function to additionally extract the attribute array at that index and return a reference to it.
            template <typename target_attribute_array_defT>
            static inline attribute_array<target_attribute_array_defT> &get_attribute_array(target_attribute_array_defT __dummy, std::vector<any_type> &m_arrays)
            {
                return *any_cast<attribute_array<target_attribute_array_defT> *>(m_arrays.at(get_attribute_index<target_attribute_array_defT>()));
            }

            // convenience function to additionally extract the attribute array at that index and return a reference to it. const-cv
            template <typename target_attribute_array_defT>
            static inline const attribute_array<target_attribute_array_defT> &get_attribute_array(target_attribute_array_defT __dummy, const std::vector<any_type> &m_arrays)
            {
                return *any_cast<const attribute_array<target_attribute_array_defT> *>(m_arrays.at(get_attribute_index<target_attribute_array_defT>()));
            }
        };

        // argument list tail case partial specialization for the recursive functions.
        template <>
        struct attribute_array_container_ops<>
        {
            static inline void build(size_t n_elems, std::vector<any_type> &m_arrays) {}
            static inline void resize_all(size_t n_elems, std::vector<any_type> &m_arrays, size_t i = 0) {}
            static inline void resize_uniform_only(size_t n_elems_old, size_t n_elems_new, std::vector<any_type> &m_arrays, size_t i = 0) {}
            static inline void reset_all_recompute_flags(std::vector<any_type> &m_arrays, size_t i = 0) {}
            static inline void destroy(std::vector<any_type> &m_arrays, size_t i = 0) {}

            template <typename target_attribute_array_defT>
            static constexpr bool has_attribute_array() {return false;}

            template <typename target_attribute_array_defT>
            static constexpr size_t get_attribute_index(size_t i = 0) {return attribute_index_none;}
        };

        // recompute operation prototype
        template <typename attribute_array_containerT, typename... attribute_array_defU>
        struct recompute_op;

        // specialization for recursive unpacking
        template <typename attribute_array_containerT, typename attribute_array_defU, typename... attribute_array_defV>
        struct recompute_op<attribute_array_containerT, attribute_array_defU, attribute_array_defV...>
        {
            // get the attribute_array_container_ops instantiation for this
            // attribute_array_container type.
            typedef
                typename attribute_array_containerT::__ops
                __ops;

            // get the attribute_dependency_unroller instantiation for this
            // attribute_array_container type and attribute_array_defU
            // pairing.
            typedef
                typename attribute_array_containerT::template attribute_dependency_unroller_impl<attribute_array_defU>
                __unroller_type;

            // the recompute functor object class for this attribute_array definition.
            typedef
                typename attribute_array_defU::recompute_functor_type
                __active_functor;

            static inline void recompute(attribute_array_containerT &m_container, const dependency_index_pair &m_pair)
            {
                // defer the variadic argument pack expansion to the unroller instantiation's function
                // to keep things clean here.
                if (__unroller_type::needs_recompute(attribute_array_defU(), m_pair, m_container))
                {
                    auto m_value = __unroller_type::recompute(attribute_array_defU(), m_pair, m_container, __active_functor());
                    m_container.get_attribute_array(attribute_array_defU()).set(m_pair.i_self, m_value);
                }

                // recursively instantiate the next recompute_op
                // to recompute the next attribute if any.
                recompute_op<attribute_array_containerT, attribute_array_defV...>::recompute(m_container, m_pair);
            }
        };

        // partial specialization for recursive recompute() function's tail case.
        template <typename attribute_array_containerT>
        struct recompute_op<attribute_array_containerT>
        {
            // stop recursing, no arguments left in pack.
            static inline void recompute(attribute_array_containerT &m_container, const dependency_index_pair &m_pair) {}
        };

        // utility to reset all recompute flags conditionally based upon
        // the input selector type. the default case does not reset anything.
        template <typename attribute_array_containerT, typename post_recompute_flag_actionT>
        struct recompute_flag_selective_reset
        {
            static inline void __impl(std::vector<any_type> &m_array) {}
        };

        // partial specialization for reset all operation.
        // defers operation to the attribute_array_container_ops
        // type so that this type does not have to be recursively
        // instantiated.
        template <typename attribute_array_containerT>
        struct recompute_flag_selective_reset<attribute_array_containerT, post_recompute_flag_action_reset>
        {
            typedef
                typename attribute_array_containerT::__ops
                __ops;

            static inline void __impl(std::vector<any_type> &m_array)
            {
                __ops::reset_all_recompute_flags(m_array);
            }
        };

        // utility to reset all recompute flags conditionally based upon
        // the input selector type. the default case does not reset anything.
        template <typename attribute_array_containerT, typename target_attribute_array_defT, typename post_recompute_flag_actionT>
        struct recompute_flag_selective_reset_single
        {
            static inline void __impl(std::vector<any_type> &m_array) {}
        };

        // partial specialization for reset all operation.
        // defers operation to the attribute_array_container_ops
        // type so that this type does not have to be recursively
        // instantiated.
        template <typename attribute_array_containerT, typename target_attribute_array_defT>
        struct recompute_flag_selective_reset_single<attribute_array_containerT, target_attribute_array_defT, post_recompute_flag_action_reset>
        {
            typedef
                typename attribute_array_containerT::__ops
                __ops;

            static inline void __impl(std::vector<any_type> &m_array)
            {
                __ops::get_attribute_array(target_attribute_array_defT(), m_array).reset_recompute_flags();
            }
        };
    }

    // the container itself.
    template <typename... attribute_array_defT>
    class attribute_array_container
    {
    public:
        // instantiates a template meta utility called
        // attribute_array_container_ops for internal use.
        typedef
            detail::attribute_array_container_ops<attribute_array_defT...>
            __ops;

        // a convenience type definition that instantiates a dependency resolution unroller
        // for the given attribute.
        template <typename target_attribute_array_defT>
        struct attribute_dependency_unroller_impl:
            target_attribute_array_defT::dependency_def_list_unroller_type::template __impl_s<attribute_array_defT...>
        {};

        // passes the definition argument pack to a dependency definition resolver.
        template <typename attribute_array_dependency_defT>
        struct resolved_dependency_def_instance:
            detail::resolved_dependency_def<attribute_array_dependency_defT, attribute_array_defT...>
        {};

        // instantiates the recompute operation meta utility.
        // this is by far the most complex operation as it involves quite a bit of
        // non linear variadic argument pack distribution and expansion.
        typedef
            detail::recompute_op<attribute_array_container, attribute_array_defT...>
            __recompute_op;

        template <typename target_attribute_array_defT>
        struct __single_recompute_op:
            detail::recompute_op<attribute_array_container, target_attribute_array_defT>
        {};
    protected:
        // a convenience type definition that instantiates the appropriate post recompute
        // reset operations
        template <typename post_recompute_flag_actionT>
        struct recompute_flag_selective_reset_instance:
            detail::recompute_flag_selective_reset<attribute_array_container, post_recompute_flag_actionT>
        {};

        template <typename target_attribute_array_defT, typename post_recompute_flag_actionT>
        struct recompute_flag_selective_reset_for_attribute:
            detail::recompute_flag_selective_reset_single<attribute_array_container, target_attribute_array_defT, post_recompute_flag_actionT>
        {};

        // a vector containing the attribute_arrays.
        // each array is of a different attribute type,
        // so we use any_type to abstract them during storage
        // without a base class.
        std::vector<any_type> m_arrays;

        // element count for each attribute_array.
        size_t n_elems;
    public:
        // defer construction to the recursive operation
        // utility class.
        attribute_array_container(size_t n_elems = 1):
            m_arrays()
        {
            m_arrays.reserve(next_pow2(n_elems > 16 ? n_elems : 16));
            __ops::build(n_elems, m_arrays);
        }

        // defer destruction to the recursive operation
        // utility class.
        virtual inline ~attribute_array_container()
        {
            __ops::destroy(m_arrays);
        }

        template <typename target_attribute_array_defT>
        static constexpr bool has_attribute_array()
        {
            return __ops::template has_attribute_array<target_attribute_array_defT>();
        }

        // get an attribute array, and automagically cast back in to a concrete class
        // using __ops::get_attribute_array.
        template <typename target_attribute_array_defT>
        inline attribute_array<target_attribute_array_defT> &get_attribute_array(target_attribute_array_defT __dummy)
        {
            return __ops::get_attribute_array(__dummy, m_arrays);
        }

        // get an attribute array, and automagically cast back in to a concrete class
        // using __ops::get_attribute_array. const-cv
        template <typename target_attribute_array_defT>
        inline const attribute_array<target_attribute_array_defT> &get_attribute_array(target_attribute_array_defT __dummy) const
        {
            return __ops::get_attribute_array(__dummy, m_arrays);
        }

        // recompute a pair of indices as parent and self, where parent is an
        // optional alternative dependency index, and self index is being modified.
        // you can use this function to manage parent/child relationships manually
        // and update in a specific order.
        template <typename post_recompute_flag_actionT = post_recompute_flag_action_none>
        inline void recompute_single_index_pair(const dependency_index_pair &m_pair, post_recompute_flag_actionT __dummy = post_recompute_flag_actionT())
        {
            // instantiate and call the incredibly complex hard
            // coded recompute dependency pattern.
            __recompute_op::recompute(*this, m_pair);

            // use the appropriate pose recompute action.
            recompute_flag_selective_reset_instance<post_recompute_flag_actionT>::__impl(m_arrays);
        }

        // recompute a pair of indices as parent and self, where parent is an
        // optional alternative dependency index, and self index is being modified.
        // you can use this function to manage parent/child relationships manually
        // and update in a specific order.
        template <typename target_attribute_array_defT, typename post_recompute_flag_actionT = post_recompute_flag_action_none>
        inline void recompute_single_index_pair_for_attribute(target_attribute_array_defT __dummy0, const dependency_index_pair &m_pair, post_recompute_flag_actionT __dummy = post_recompute_flag_actionT())
        {
            // instantiate and call the incredibly complex hard
            // coded recompute dependency pattern.
            __single_recompute_op<target_attribute_array_defT>::recompute(*this, m_pair);

            // use the appropriate pose recompute action.
            recompute_flag_selective_reset_for_attribute<target_attribute_array_defT, post_recompute_flag_actionT>::__impl(m_arrays);
        }

        // recomputes the given list of pairs between the two iterators.
        // these can come from any naked container class (e.g. vector,
        // set, not hash_map/map, no others with an element type not
        // implicitly castable to dependency_index_pair.
        template <typename iteratorT, typename post_recompute_flag_actionT = post_recompute_flag_action_none>
        inline void recompute_index_pairs(iteratorT _begin, iteratorT _end, post_recompute_flag_actionT __dummy = post_recompute_flag_actionT())
        {
            for (auto it = _begin; it != _end; ++it)
                __recompute_op::recompute(*this, *it);

            // use the appropriate pose recompute action.
            recompute_flag_selective_reset_instance<post_recompute_flag_actionT>::__impl(m_arrays);
        }

        // variant that assumes the single parameter is a container class.
        // sometimes cleaner than passing a pair of begin/end iterators.
        template <typename containerT, typename post_recompute_flag_actionT = post_recompute_flag_action_none>
        inline void recompute_index_pairs(const containerT &m_container, post_recompute_flag_actionT __dummy = post_recompute_flag_actionT())
        {
            for (const dependency_index_pair &m_pair: m_container)
                __recompute_op::recompute(*this, m_pair);

            // use the appropriate pose recompute action.
            recompute_flag_selective_reset_instance<post_recompute_flag_actionT>::__impl(m_arrays);
        }

        // variant that takes an array of dependency_index_pairs.
        template <typename post_recompute_flag_actionT = post_recompute_flag_action_none>
        inline void recompute_index_pairs(const dependency_index_pair *m_pair_array, size_t n_pairs, post_recompute_flag_actionT __dummy = post_recompute_flag_actionT())
        {
            for (size_t i = 0; i < n_pairs; ++i)
                __recompute_op::recompute(*this, m_pair_array[i]);

            // use the appropriate pose recompute action.
            recompute_flag_selective_reset_instance<post_recompute_flag_actionT>::__impl(m_arrays);
        }

        // recomputes the given list of pairs between the two iterators.
        // these can come from any naked container class (e.g. vector,
        // set, not hash_map/map, no others with an element type not
        // implicitly castable to dependency_index_pair.
        template <typename target_attribute_array_defT, typename iteratorT, typename post_recompute_flag_actionT = post_recompute_flag_action_none>
        inline void recompute_index_pairs_for_attribute(target_attribute_array_defT __dummy0, iteratorT _begin, iteratorT _end, post_recompute_flag_actionT __dummy = post_recompute_flag_actionT())
        {
            for (auto it = _begin; it != _end; ++it)
                __single_recompute_op<target_attribute_array_defT>::recompute(*this, *it);

            // use the appropriate pose recompute action.
            recompute_flag_selective_reset_for_attribute<target_attribute_array_defT, post_recompute_flag_actionT>::__impl(m_arrays);
        }

        // variant that assumes the single parameter is a container class.
        // sometimes cleaner than passing a pair of begin/end iterators.
        template <typename target_attribute_array_defT, typename containerT, typename post_recompute_flag_actionT = post_recompute_flag_action_none>
        inline void recompute_index_pairs_for_attribute(target_attribute_array_defT __dummy0, const containerT &m_container, post_recompute_flag_actionT __dummy = post_recompute_flag_actionT())
        {
            for (const dependency_index_pair &m_pair: m_container)
                __single_recompute_op<target_attribute_array_defT>::recompute(*this, m_pair);

            // use the appropriate pose recompute action.
            recompute_flag_selective_reset_for_attribute<target_attribute_array_defT, post_recompute_flag_actionT>::__impl(m_arrays);
        }

        // variant that takes an array of dependency_index_pairs.
        template <typename target_attribute_array_defT, typename post_recompute_flag_actionT = post_recompute_flag_action_none>
        inline void recompute_index_pairs_for_attribute(target_attribute_array_defT __dummy0, const dependency_index_pair *m_pair_array, size_t n_pairs, post_recompute_flag_actionT __dummy = post_recompute_flag_actionT())
        {
            for (size_t i = 0; i < n_pairs; ++i)
                __single_recompute_op<target_attribute_array_defT>::recompute(*this, m_pair_array[i]);

            // use the appropriate pose recompute action.
            recompute_flag_selective_reset_for_attribute<target_attribute_array_defT, post_recompute_flag_actionT>::__impl(m_arrays);
        }

        inline void reset_all_recompute_flags()
        {
            recompute_flag_selective_reset_instance<post_recompute_flag_action_reset>::__impl(m_arrays);
        }

        // gets the target size of each attribute_array
        inline size_t size() const
        {
            return n_elems;
        }

        // resize all attribute_arrays to n_elems or
        // to the target size if n_elems is 0.
        inline void resize(size_t n_elems = 0)
        {
            if (n_elems > 0)
            {
                this->n_elems = n_elems;
                __ops::resize_all(this->n_elems, m_arrays);
            }
            else
                resize(size());
        }

        // resize all attribute_arrays to n_elems or
        // to the target size if n_elems is 0.
        inline void resize_uniform_arrays(size_t n_elems = 0)
        {
            if (n_elems > 0)
            {
                __ops::resize_non_uniform(this->n_elems, n_elems, m_arrays);

                this->n_elems = n_elems;
            }
        }
    };

    /*
    // do not use... BROKEN!
    template <typename attribute_array_defT, typename containerT>
    void __debug_dump_attribute_array(std::ostream &m_o, const containerT &m_container, attribute_array_defT __dummy)
    {
        const auto &m_attr_array = m_container.get_attribute_array(__dummy);

        m_o << "dump for attribute array from ID=" << attribute_array_defT::ID << " type=" << typeid(typename attribute_array_defT::type).name() << std::endl;

        const auto &m_pair = m_attr_array.get(attribute_array_default_index);
        m_o << "    default: " << m_pair.first << " , " << m_pair.second << std::endl;

        for (size_t i = 0; i < m_attr_array.size(); ++i)
        {
            const auto &m_pair = m_attr_array.get(i);
            m_o << "     [" << i << "]: " << m_pair.first << " , " << m_pair.second;
        }
    }*/

    namespace detail
    {
        template <typename attribute_array_containerT, typename target_attribute_array_defT>
        struct __attribute_array_container_has_helper:
            std::integral_constant<bool, attribute_array_containerT::template has_attribute_array<target_attribute_array_defT>()>
        {};
    }

    template <typename attribute_array_containerT, typename target_attribute_array_defT>
    static constexpr bool attribute_array_container_has()
    {
        return detail::__attribute_array_container_has_helper<attribute_array_containerT, target_attribute_array_defT>::value;
    }

    template <typename attribute_array_containerT, typename target_attribute_array_defT>
    static constexpr bool attribute_array_container_has(const attribute_array_containerT &m_container)
    {
        return detail::__attribute_array_container_has_helper<attribute_array_containerT, target_attribute_array_defT>::value;
    }
}

#endif
